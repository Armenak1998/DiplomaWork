#include "pin.h"
#include "cell.h"
#include <QGraphicsRectItem>
#include <QGraphicsScene>
#include <algorithm>

///////////////////////////////////////////////////////////////////////////////////////////////
// ! initialization static member pin
///////////////////////////////////////////////////////////////////////////////////////////////
std::vector<Pin> Pin::s_pins;

///////////////////////////////////////////////////////////////////////////////////////////////
// ! constructor Pin
///////////////////////////////////////////////////////////////////////////////////////////////
Pin::Pin(std::string name, int x, int y, EAD::DIRECTION direction) :
    DBObject(name), m_point(x, y), m_direction(direction)
{
}

///////////////////////////////////////////////////////////////////////////////////////////////
// ! Pin isAllowed
///////////////////////////////////////////////////////////////////////////////////////////////
const std::vector<Pin>& Pin::getAllPin()
{
    return s_pins;

}

///////////////////////////////////////////////////////////////////////////////////////////////
// ! Pin getCell
///////////////////////////////////////////////////////////////////////////////////////////////
bool Pin::getPin(const std::string& name, Pin& pin)
{
    for (const auto& item : s_pins) {
        if (item.getName() == name) {
            pin = item;
            return true;
        }
    }
    return false;
}

bool Pin::operator==(const Pin& pin)
{
    bool status = true;
    status &= (m_name == pin.m_name);
    status &= (m_point == pin.m_point);
    status &= (m_direction == pin.m_direction);
    return status;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// ! Pin find
///////////////////////////////////////////////////////////////////////////////////////////////
bool Pin::find(const Pin& pin)
{
    const auto& finde = std::find(s_pins.begin(), s_pins.end(), pin);
    if (finde == s_pins.cend()) {
        return false;
    }
    return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// ! Pin addCell
///////////////////////////////////////////////////////////////////////////////////////////////
bool Pin::addPin(const Pin& pin)
{
    if (find(pin)) {
        return false;
    }
    s_pins.push_back(pin);
    return true;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// ! destructor Pin
///////////////////////////////////////////////////////////////////////////////////////////////
Pin::~Pin()
{
    s_pins.erase(std::remove(s_pins.begin(), s_pins.end(), *this), s_pins.end());
}

///////////////////////////////////////////////////////////////////////////////////////////////
// ! Pin draw
///////////////////////////////////////////////////////////////////////////////////////////////
void Pin::draw(QGraphicsScene* scan) const
{
    QPen pen(Qt::blue);
    scan->addRect(m_point.x(), m_point.y(), 1, 1, pen);


    //QPen pen;
    //if (m_status == Status::IN) {
    //    pen.setColor(Qt::darkGreen);
    //} else {
    //    pen.setColor(Qt::darkBlue);
    //}
    //scan->addRect(x(), y(), 1, 1, pen);
}



































































































///////////////////////////////////////////////////////////////////////////////////////////////
// ! Pin getName
///////////////////////////////////////////////////////////////////////////////////////////////
//std::string Pin::getName() const
//{
//    return m_name;
//}

///////////////////////////////////////////////////////////////////////////////////////////////
// ! Pin repetitiveName
///////////////////////////////////////////////////////////////////////////////////////////////
//bool Pin::repetitiveName(std::string name)
//{
//    for(const auto& item : pins_list) {
//        if (item->getName() == name) {
//            return true;
//        }
//    }
//    return false;
//}
//
///////////////////////////////////////////////////////////////////////////////////////////////
// ! Pin getPinByName
///////////////////////////////////////////////////////////////////////////////////////////////
//Pin* Pin::getPinByName(std::string name)
//{
//    for(const auto& item : pins_list) {
//        if (item->getName() == name) {
//            return item;
//        }
//    }
//    return nullptr;
//}
/////////////////////////////////////////////////////////////////////////////////////////////////
//// ! Pin getPinByName
/////////////////////////////////////////////////////////////////////////////////////////////////
//Status Pin::getStatus()const
//{
//    return m_status;
//}
//
/////////////////////////////////////////////////////////////////////////////////////////////////
//// ! Pin getPinList
/////////////////////////////////////////////////////////////////////////////////////////////////
//std::vector<Pin*> Pin::getPinList()
//{
//    return pins_list;
//}
//
/////////////////////////////////////////////////////////////////////////////////////////////////
//// ! Pin getPinList
/////////////////////////////////////////////////////////////////////////////////////////////////
//cell* Pin::getBase() const {
//    return m_base;
//}
//
/////////////////////////////////////////////////////////////////////////////////////////////////
//// ! Pin getPinList
/////////////////////////////////////////////////////////////////////////////////////////////////
//void Pin::setBase(cell* _base) {
//    m_base = _base;
//}
//
/////////////////////////////////////////////////////////////////////////////////////////////////
//// ! initialization static member port
/////////////////////////////////////////////////////////////////////////////////////////////////
//std::string port::default_name = "port_default_";
//int port::INDEX = 1;
//std::vector<port*> port::ports_list;
//
/////////////////////////////////////////////////////////////////////////////////////////////////
//// ! constructor port
/////////////////////////////////////////////////////////////////////////////////////////////////
//port::port(std::string name, int x, int y, Status status) :
//    QPoint(x, y), m_status(status)
//{
//    if (x == 0) {
//        m_pin = new pin("pin_" + name, x + 7, y + 2, status);
//    } else {
//        m_pin = new pin("pin_" + name, x - 5, y + 2, status);
//    }
//    if ((name[0] != 'p') && (name[0] != 'o') && (name[0] != 'r')
//            && (name[0] != 't') && (name[0] != '_')) {
//        m_name = "port_";
//        m_name += name;
//    } else {
//        m_name = name;
//    }
//    if (repetitiveName(m_name)) {
//        std::string n = default_name + std::to_string(INDEX++);
//        while (repetitiveName(n)) {
//            n = default_name + std::to_string(INDEX++);
//        }
//        m_name = n;
//        //throw (RepetitiveName());
//    } else {
//        ports_list.push_back(this);
//    }
//
//}
//
/////////////////////////////////////////////////////////////////////////////////////////////////
//// ! destructor port
/////////////////////////////////////////////////////////////////////////////////////////////////
//port::~port()
//{
//    ports_list.erase(std::remove(ports_list.begin(), ports_list.end(), this), ports_list.end());
//}
//
/////////////////////////////////////////////////////////////////////////////////////////////////
//// ! port draw
/////////////////////////////////////////////////////////////////////////////////////////////////
//void port::draw(QGraphicsScene* scan) const
//{
//   /* QPen pen(Qt::blue);
//    pen.setWidthF(0.5);
//    QBrush bras(Qt::lightGray);//scan->backgroundBrush();
//    if(this->rect().x() == 0) {
//        //scan->addRect(this->rect().x() + 7, this->rect().y() + 2, 4.5, 5, pen, bras);
//        scan->addRect(m_pin->rect(), pen, bras);
//        scan->addRect(this->rect().x() - 1, this->rect().y() , this->rect().width() + 1, this->rect().height(), pen, bras);
//    } else {
//        //scan->addRect(this->rect().x() - 4, this->rect().y() + 2, 4.5, 5, pen, bras);
//        scan->addRect(m_pin->rect(), pen, bras);
//        scan->addRect(this->rect().x(), this->rect().y(), this->rect().width() + 1, this->rect().height(), pen, bras);
//    }*/
//    QPen pen(Qt::blue);
//    scan->addRect(x(), y(), 1, 1, pen);
//}
//
/////////////////////////////////////////////////////////////////////////////////////////////////
//// ! port get_name
/////////////////////////////////////////////////////////////////////////////////////////////////
//std::string port::getName() const
//{
//    return m_name;
//}
/////////////////////////////////////////////////////////////////////////////////////////////////
//// ! port repetitiveName
/////////////////////////////////////////////////////////////////////////////////////////////////
//bool port::repetitiveName(std::string name)
//{
//    for(const auto& item : ports_list) {
//        if (item->getName() == name) {
//            return true;
//        }
//    }
//    return false;
//}
//
/////////////////////////////////////////////////////////////////////////////////////////////////
//// ! port getPinByName
/////////////////////////////////////////////////////////////////////////////////////////////////
//port* port::getPortByName(std::string name)
//{
//    for(const auto& item : ports_list) {
//        if (item->getName() == name) {
//            return item;
//        }
//    }
//    return nullptr;
//}
//
/////////////////////////////////////////////////////////////////////////////////////////////////
//// ! port getStatus
/////////////////////////////////////////////////////////////////////////////////////////////////
//Status port::getStatus()const
//{
//    return m_status;
//}
//
/////////////////////////////////////////////////////////////////////////////////////////////////
//// ! port getpin
/////////////////////////////////////////////////////////////////////////////////////////////////
//pin* port::getPin() const
//{
//    return m_pin;
//}
